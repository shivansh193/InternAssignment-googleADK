import { NextRequest, NextResponse } from 'next/server';
import { AgentOrchestrator } from '../../../../backend/services/AgentOrchestrator'; // Adjust path if needed
import { ChatResponse } from '../../../../backend/types/index';
import { logger } from '../../../../backend/utils/logger';
import { v4 as uuidv4 } from 'uuid';
import { z } from 'zod'; // From backend-lib/middleware/validation

// Re-define or import your Zod schema
const chatRequestSchema = z.object({
  message: z.string().min(1).max(2000),
  sessionId: z.string().optional(),
  context: z.array(z.object({
    id: z.string(),
    content: z.string(),
    sender: z.enum(['user', 'assistant']),
    timestamp: z.union([z.string(), z.date()]).transform(val => new Date(val)),
    agent: z.enum(['tutor', 'math', 'physics']).optional()
  })).optional()
});

const orchestrator = new AgentOrchestrator();

// Optional: Implement rate limiting here or via Next.js Middleware
// import { rateLimiter } from '@/backend-lib/middleware/rateLimiting'; // if adapting

export async function POST(req: NextRequest) {
  try {
    // Optional: Rate limiting
    // const ip = req.ip ?? '127.0.0.1';
    // try {
    //   await rateLimiter.consume(ip);
    // } catch (rejRes: any) {
    //   const secs = Math.round(rejRes.msBeforeNext / 1000) || 1;
    //   return NextResponse.json(
    //     { error: 'Too many requests', retryAfter: secs },
    //     { status: 429, headers: { 'Retry-After': String(secs) } }
    //   );
    // }

    console.log('API: Received chat request');
    
    const body = await req.json();
    console.log('API: Request body received:', { 
      message: body.message?.substring(0, 50) + '...',
      sessionId: body.sessionId,
      contextLength: body.context ? body.context.length : 0
    });
    
    const validationResult = chatRequestSchema.safeParse(body);

    if (!validationResult.success) {
      console.error('API: Validation error:', validationResult.error.errors);
      return NextResponse.json(
        { error: 'Validation error', details: validationResult.error.errors },
        { status: 400 }
      );
    }

    const { message, sessionId, context } = validationResult.data;
    console.log('API: Validated data:', { 
      messageLength: message.length,
      sessionId,
      contextLength: context ? context.length : 0,
      contextSample: context && context.length > 0 ? {
        firstMessage: {
          id: context[0].id,
          sender: context[0].sender,
          timestampType: typeof context[0].timestamp
        }
      } : 'No context'
    });
    
    logger.info(`Chat request from session ${sessionId}: ${message.substring(0, 100)}...`);

    console.log('API: Calling orchestrator.routeMessage');
    const agentResponse = await orchestrator.routeMessage(message, context);

    const response: ChatResponse = {
      message: agentResponse.content,
      agent: agentResponse.agent,
      timestamp: new Date(),
      sessionId: sessionId || uuidv4(),
      toolsUsed: agentResponse.toolsUsed,
      analysis: agentResponse.analysis,
      specialistResponse: agentResponse.specialistResponse,
      toolResults: agentResponse.toolResults,
      formattedEquations: agentResponse.formattedEquations
    };

    console.log('API: Response generated:', {
      agent: agentResponse.agent,
      messagePreview: agentResponse.content.substring(0, 50) + '...',
      toolsUsed: agentResponse.toolsUsed
    });

    logger.info(`Response generated by ${agentResponse.agent} agent`);
    return NextResponse.json(response);

  } catch (error) {
    console.error('API: Chat endpoint error:', error);
    logger.error('Chat endpoint error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    return NextResponse.json(
      { error: 'Internal server error', message: errorMessage },
      { status: 500 }
    );
  }
}