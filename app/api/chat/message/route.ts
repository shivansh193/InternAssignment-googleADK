import { NextRequest, NextResponse } from 'next/server';
import { AgentOrchestrator } from '../../../../backend/services/AgentOrchestrator'; // Adjust path if needed
import { ChatResponse } from '../../../../backend/types/index';
import { logger } from '../../../../backend/utils/logger';
import { v4 as uuidv4 } from 'uuid';
import { z } from 'zod'; // From backend-lib/middleware/validation

// Re-define or import your Zod schema
const chatRequestSchema = z.object({
  message: z.string().min(1).max(2000),
  sessionId: z.string().optional(),
  context: z.array(z.object({
    id: z.string(),
    content: z.string(),
    sender: z.enum(['user', 'assistant']),
    timestamp: z.union([z.string(), z.date()]).transform(val => new Date(val)),
    agent: z.enum(['tutor', 'math', 'physics']).optional()
  })).optional()
});

// Safely initialize the orchestrator with error handling
let orchestrator: AgentOrchestrator;
try {
  orchestrator = new AgentOrchestrator();
  console.log('API: AgentOrchestrator initialized successfully');
} catch (error) {
  console.error('API: Failed to initialize AgentOrchestrator:', error);
  // We'll handle this error when the endpoint is called
}

// Optional: Implement rate limiting here or via Next.js Middleware
// import { rateLimiter } from '@/backend-lib/middleware/rateLimiting'; // if adapting

// Handle OPTIONS requests for CORS preflight
export async function OPTIONS() {
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization',
    },
  });
}

export async function POST(req: NextRequest) {
  try {
    // Add debugging for Vercel environment
    console.log('API: Environment variables check:', {
      nodeEnv: process.env.NODE_ENV,
      hasGeminiKey: !!process.env.GEMINI_API_KEY,
      corsOrigin: process.env.CORS_ORIGIN
    });
    // Optional: Rate limiting
    // const ip = req.ip ?? '127.0.0.1';
    // try {
    //   await rateLimiter.consume(ip);
    // } catch (rejRes: any) {
    //   const secs = Math.round(rejRes.msBeforeNext / 1000) || 1;
    //   return NextResponse.json(
    //     { error: 'Too many requests', retryAfter: secs },
    //     { status: 429, headers: { 'Retry-After': String(secs) } }
    //   );
    // }

    console.log('API: Received chat request');
    
    const body = await req.json();
    console.log('API: Request body received:', { 
      message: body.message?.substring(0, 50) + '...',
      sessionId: body.sessionId,
      contextLength: body.context ? body.context.length : 0
    });
    
    const validationResult = chatRequestSchema.safeParse(body);

    if (!validationResult.success) {
      console.error('API: Validation error:', validationResult.error.errors);
      return NextResponse.json(
        { error: 'Validation error', details: validationResult.error.errors },
        { status: 400 }
      );
    }

    const { message, sessionId, context } = validationResult.data;
    console.log('API: Validated data:', { 
      messageLength: message.length,
      sessionId,
      contextLength: context ? context.length : 0,
      contextSample: context && context.length > 0 ? {
        firstMessage: {
          id: context[0].id,
          sender: context[0].sender,
          timestampType: typeof context[0].timestamp
        }
      } : 'No context'
    });
    
    logger.info(`Chat request from session ${sessionId}: ${message.substring(0, 100)}...`);

    console.log('API: Checking if orchestrator is initialized');
    if (!orchestrator) {
      throw new Error('AgentOrchestrator failed to initialize. Check the Gemini API key and other configuration.');
    }
    
    console.log('API: Calling orchestrator.routeMessage');
    const agentResponse = await orchestrator.routeMessage(message, context);

    const response: ChatResponse = {
      message: agentResponse.content,
      agent: agentResponse.agent,
      timestamp: new Date(),
      sessionId: sessionId || uuidv4(),
      toolsUsed: agentResponse.toolsUsed,
      analysis: agentResponse.analysis,
      specialistResponse: agentResponse.specialistResponse,
      toolResults: agentResponse.toolResults,
      formattedEquations: agentResponse.formattedEquations
    };

    console.log('API: Response generated:', {
      agent: agentResponse.agent,
      messagePreview: agentResponse.content.substring(0, 50) + '...',
      toolsUsed: agentResponse.toolsUsed
    });

    logger.info(`Response generated by ${agentResponse.agent} agent`);
    return NextResponse.json(response);

  } catch (error) {
    console.error('API: Chat endpoint error:', error);
    logger.error('Chat endpoint error:', error);
    const errorMessage = error instanceof Error ? error.message : 'Unknown error';
    
    // Create a safe error response that will always be valid JSON
    return NextResponse.json(
      { 
        error: true, 
        message: 'Internal server error', 
        details: errorMessage,
        timestamp: new Date().toISOString()
      },
      { 
        status: 500,
        headers: {
          'Content-Type': 'application/json',
          'Access-Control-Allow-Origin': '*',
          'Access-Control-Allow-Methods': 'POST, OPTIONS',
          'Access-Control-Allow-Headers': 'Content-Type, Authorization'
        }
      }
    );
  }
}